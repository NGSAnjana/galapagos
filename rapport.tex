\documentclass{article}
\usepackage[latin1]{inputenc}

\pagestyle{plain}

\title{Eksamensproject i Object-Orienteret Programmering \& Design}

\author{Martin Dybdal, Mikkel Abrahamsen, Sune Precht Reeh, Troels Henriksen}

\date{Januar 2007}
\begin{document}
\maketitle

\section{Forfatterinformation}

Mikkel Abrahamsen \\
\noindent
Jagtvej 120,3,-346 \\
\noindent
2200 København N \\
\noindent
Eksamensnummer: 37

\section{Indledning}

\section{Programdesign}

\subsection{Model}

\subsubsection{\tt World}

Den fundamentale datastruktur, der ligger til grund for hele
simulationens  verden, er den passende navngivne klasse {\tt World}.
Denne klasse giver i sin enkelthed adgang til et todimensionelt array
af {\tt World.Place} objekter. Disse {\tt World.Place}s skaber
verdens torusform, som krævet i opgaven, idet de har metoder til at
finde nabo-{\tt World.Place}s. Et af disse objekter, placeret på en
kant, vil give de passende objekter på den modsatte kant, når der
bliver spurgt om sine naboer. Et {\tt World.Place} objekt kan også
indeholde et andet objekt - dets {\em element}. I vores simulation er
finke-objekterne placeret som elementer i {\tt World.Place} objekter,
men da man kan forestille sig at der sidenhen kan være behov for at
lave {\tt World}-strukturer med andre typer objekter end finker, har
vi valgt at benytte generics til {\tt World}-klassen.

Metoderne {\tt World.Place.filledNeighbors} og {\tt
  World.Place.emptyNeighbors} bruges til at finde de naboceller der
  hhv. indeholder elementer eller er tommer. De skal benyttes når
  finker skal få afkom og møde andre finker.

Under simulationen er der ydermere endnu en interessant facilitet, vi
ofte har behov for at udføre på vores verden - når der skal arrangeres
møder og skabes afkom, skal vi iterere igennem alle finker i verden,
men for ikke skabe favoritter, skal dette helst ske i pseudotilfældig
rækkefølge. Ydermere ønsker vi et iteratorbaseret interface for at
gøre koden så elegant som muligt. En åbenlys implementation er at lade
{\tt World} klone dets underliggende lager (en enkeltdimensional {\tt
  ArrayList}), kalde {\tt Collections.shuffle} på det nye array, og
returnere en iterator. Dette ville resultere i allokeringen af et nyt
array for hver gang vi har behov for at iterere igennem elementerne i
{\tt World} i pseudotilfældig rækkefølge - en åbenlys ineffektiv
implementation. Vi har dog - ved at observere at {\tt
  World.Place}-objekterne i {\tt World} aldrig ændrer sig, kun deres
elementer - fundet på en mere effektiv implementation, hvor vi i {\tt
  World}, sideløbende med det almindelige lager, gemmer et alternativt
lager, der indeholder de samme {\tt World.Place} objekter som det
primære, men i en anden rækkefølge. Idet det er de samme {\tt
  World.Place}-objekter der bliver modificeret når der tilføjes og
fjernes finker, vil dette array altid være opdateret mht. indhold, og
vi kan implementere tilfældig iteration blot ved at kalde {\tt
  Collections.shuffle} på det og returnere en iterator. Derved slipper
vi for at skulle klone vores underliggende array hver gang vi har
behov for pseudotilfældig iteration.

\subsubsection{\tt GalapagosFinch}

En instans af klassen {\tt GalapagosFinch} repræsenterer én
finke. Klassen {\tt GalapagosFinch} implementerer interfacet {\tt
  Finch}, der bruges som reference til en {\tt GalapagosFinch} på
steder hvor det ikke er tilsigtet at {\tt GalapagsoFinch}en skal kunne
ændres på nogen måde.

En {\tt GalapagosFinch} har én {\tt Behavior}. Det er {\tt
  Behavior}ens ansvar at afgøre om {\tt GalapagosFinch}en vil hjælpe
en given finke eller ej, ligesom {\tt Behavior}en underrettes om
hvorledes andre finker har handlet overfor {\tt GalapagosFinch}en.

Metoden {\tt decide} i
{\tt GalapagosFinch} bruges når man har brug for at få at vide, om
{\tt GalapagosFinch}en vil hjælpe en anden finke eller ej (i første
tilfælde returneres {\tt FinchStatus.CLEANING}, i andet tilfælde
returneres {\tt FinchStatus.IGNORING}). 
Når {\tt decide} kaldes
returneres resultatet af
{\tt Behavior}ens {\tt decide}-metode på den pågældende finke.

Med metoden {\tt response} modtager {\tt GalapagosFinch}en information
om hvordan en given anden {\tt Finch} har handlet mod den. Dette gives
videre til {\tt GalapagosFinch}ens {\tt Behavior}, ved at kalde dennes
{\tt response}-metode.

Metoden {\tt status} bruges til at afgøre om {\tt GalapagosFinch}en
 er levende, død af utøj
eller død af alderdom, sådan at man kan fjerne den fra simulationen
hvis den ikke længere bør være der.

\subsubsection{\tt Behavior}

Interfacet {\tt Behavior} er en specifikation af en finkes opførsel
i forbindelse med møder med andre finker.

Resultatet af {\tt decide} beskriver om en {\tt Finch} skal hjælpes
eller ej.

{\tt response} modtager information om hvad en anden finke handlede
under et møde med den {\tt Finch} som den pågældende {\tt Behavior}
tilhører.

Enhver implementation af {\tt Behavior} har sin egen
{\tt toString}-metoden, og denne bruges til at afgøre hvilken slags
{\tt Behavior} en given {\tt Behavior} er.

Enhver klasse der
repræsenterer en finkeopførsel som afhænger af hvordan finken er
blevet behandlet, udvider den abstrakte klasse {\tt
  MemoryBehavior}.

{\tt MemoryBehavior} er parametriseret med den generiske variabel {\tt
  DATA}, og klassevariablen {\tt finches} er et
{\tt WeakHashMap<Finch, DATA>}, som bruges når man ønsker at knytte
{\tt DATA} til en eller anden {\tt Finch}. Dette danner grundlaget for
senere at kunne afgøre hvordan der
skal handles i et møde ud fra de foregående møder.

{\tt MemoryBehavior} indeholder metoden {\tt recall} til at hente den {\tt
  DATA} der er knyttet til en given {\tt Finch}, og {\tt remember}
til at knytte {\tt DATA}
til en given {\tt Finch} i {\tt finches}.

Den abstrakte klasse {\tt ActionMemoryBehavior} udvider {\tt
  MemoryBehavior<Action>}, og udvides af alle typer af opførsler
der til en given {\tt Finch} behøver at huske én {\tt Action}. Dette
være sig fx {\tt Grudger} og {\tt TitForTat}.

\subsubsection{\tt Biotope}

{\tt Biotope}-klassen er simulationens grundsten, den klasse, der
implementere al logikken i programmet. {\tt Biotope} er ganske simpel
at bruge - essentielt foregår det ved at levere en liste af {\tt
  Behavior}-objekter som beskriver de forskellige opførsler de
simulerede finker skal benytte sig af. Ved at kalde metoden {\tt
  runRound} simuleres en enkelt runde af simulationen, og eventuelle
observerende objekter gøres opmærksomme på ændringer i simulationens
tilstand. Det er {\tt Biotope}-klassens ansvar at oprette og
vedligeholde objekter til at repræsentere spilverdenen ({\tt World})
og finkerne i den ({\tt GalapagosFinch}).

For at simulationen skal være fair, er det nødvendigt at f.eks.
muligheden for at få afkom bliver besluttet tilfældigt - da der
utvivlsomt opstår situationer hvor flere finker deles om et tomt
nabofelt som kan fyldes med afkom, er det ikke nok at bruge en naiv
iteration, som f.eks. række for række igennem verden, da det så ville
favoritisere finker nordvest i spilverdenen. Det er {\tt
  Biotope}-klassens ansvar at sørge for at disse situationer bliver
løst på fair vis. Det er også {\tt Biotope}-klassens ansvar at samle
ændringer undervejs i en runde i et {\tt Statistics}-objekt, som
observers kan bruge til at få et bredt billede af begivenhederne i en
runde.


\subsection{Brugerinterface}

\section{Konklusion}

\end{document}
