\documentclass{article}
\usepackage[latin1]{inputenc}
\usepackage[danish]{babel}

\textheight = 625pt \textwidth = 400pt \oddsidemargin = 25pt

\pagestyle{plain}

\title{Eksamensprojekt i Objektorienteret \linebreak programmering og design}

\author{Mikkel Abrahamsen, Martin Dybdal, Troels Henriksen, Sune Precht Reeh}

\date{Januar 2007}
\begin{document}
\maketitle

\section{Forfatterinformation}


Mikkel Abrahamsen

\noindent Jagtvej 120,3,-346

\noindent 2200 København N

\noindent Eksamensnummer: 37

\vspace{20pt} \noindent Martin Dybdal

\noindent Lyngestationsvej 3F

\noindent 3540 Lynge

\noindent Eksamensnummer: 21

\noindent Har ikke arbejdet på eksamensopgaven lørdag den 13., mandag
den 15. og onsdag den 17. januar.

\vspace{20pt} \noindent Troels Henriksen

\noindent Åparken 48

\noindent 2605 Brøndby

\noindent Eksamensnummer: 72

\noindent Har ikke arbejdet på eksamensopgaven søndag den 14., mandag
den 15. og onsdag den 17. januar.

\vspace{20pt} \noindent Sune Precht Reeh

\noindent Kai Hoffmanns Allé 27

\noindent 2750 Ballerup

\noindent Eksamensnummer: 64

\section{Programdesign}

Programmet er opdelt efter klare ansvarsgrænser med veldefinerede
interfaces der adskiller programmets logik i logiske enheder. En
overordnet ramme (en instans af {\tt GalapagosFrame})
fungerer som kontrolpanel for simulationen, der er
repræsenteret som en instans af klassen {\tt Biotope}. Rammen
interagerer ikke med de klasser der opbygger simulationen (såsom
den datastruktur verdens tilstand gemmes i, eller den konkrete klasse
der repræsenterer finker), men uddelegerer i stedet dette til
biotopobjektet. %Det er dog nødvendigt at lade rammen kende til
%visse specifikke simulationsklasser, for at f.eks. statistik kan
%præsenteres på en brugbar måde.

Interaktionen mellem simulationen og brugerinterfacet er struktureret
efter {\em Model-View-Controller}-designmønstret, hvori modellen (i
vores tilfælde biotop-simulationen) er uafhængig af hvorledes dens
tilstand bliver repræsenteret grafisk eller tekstuelt, og hvor dens
virkemåde styres igennem et dedikeret {\em Controller}-objekt. I vores
implementation er de grafiske kontrolværktøjer, fx knapper, forbundet
til kommandoer i vores Controller, der så igen manipulerer
biotop-objektet.

\subsection{Model}

\subsubsection{\tt World}

Den fundamentale datastruktur, der ligger til grund for hele
simulationens verden, er den passende navngivede klasse {\tt World}.
Denne klasse giver i sin enkelthed adgang til et todimensionalt array
af {\tt World.Place}-objekter (fremover kaldet felter).
Disse felter skaber verdens
torusform, som krævet i opgaven, idet de har metoder til at finde
nabofelter. Et af disse objekter, placeret på en kant,
vil give de passende felter på den modsatte kant, når der bliver
spurgt om dets naboer. Et felt kan indeholde et
andet objekt - dets {\em element}. I vores simulation er
finkeobjekterne placeret som elementer på felterne,
men da man kan forestille sig at der sidenhen kan være behov for at
lave {\tt World}-strukturer med andre typer objekter end finker, har
vi valgt at parametrisere {\tt World}-klassen over den type elementer
som felterne indeholder.
% Skal det nævnes at World er en form for ArrayList Dekorator? evt formulering: 
% (kræver en mindre rettelse længere nede)
%
% Man kan se {\tt World} som en {\tt ArrayList} "Decorator". Idet at vi
% internt bruger en sådan liste til at repræsentere torus-formen.

Et felt har metoderne {\tt filledNeighbors} og {\tt
  emptyNeighbors} til at finde alle de nabofelter
der indeholder elementer hhv. er tomme. De skal benyttes når
finker skal få afkom og møde andre finker.

%Under simulationen er der endnu en interessant facilitet vi ofte har
%behov for at udføre på vores verden.
Når der skal arrangeres møder og
skabes afkom skal vi iterere igennem alle finker i verden, men for
ikke skabe favoritter skal dette helst ske i pseudotilfældig
rækkefølge. Ydermere ønsker vi et iteratorbaseret interface for at
gøre koden så elegant som muligt. En åbenlys implementation er at lade
{\tt World} klone dets underliggende lager (en enkeltdimensional {\tt
  ArrayList}), kalde {\tt Collections.shuffle} på det nye array, og
returnere en iterator. Dette ville resultere i allokeringen af et nyt
array for hver gang vi har behov for at iterere igennem elementerne i
{\tt World} i pseudotilfældig rækkefølge - en åbenlys ineffektiv
implementation. Vi har - ved at observere at felterne
 i {\tt World} aldrig udskiftes eller ombyttes (det er kun
deres elementer der ændrer sig) - fundet på en mere effektiv
implementation, hvor vi i {\tt World}, sideløbende med det almindelige
lager, gemmer et alternativt lager, der indeholder de samme felter
som det primære, men i en anden rækkefølge.
Idet det er de samme felter der bliver modificeret
når der tilføjes og fjernes finker, vil dette sekundære array altid
være opdateret mht.  indhold, og vi kan implementere tilfældig
iteration blot ved at kalde {\tt Collections.shuffle} på det og
returnere en iterator. Derved slipper vi for at skulle klone vores
underliggende array hver gang vi har behov for pseudotilfældig
iteration.

\subsubsection{\tt GalapagosFinch}

En instans af klassen {\tt GalapagosFinch} repræsenterer én finke.
Klassen {\tt GalapagosFinch} implementerer interfacet {\tt Finch}, der
bruges som reference til en finke på steder hvor det
ikke er tilsigtet at man skal kunne få ekstra oplysninger om finken
eller ændre den på nogen måde (det vil naturligvis
stadig være muligt at "type-caste" en {\tt Finch} til {\tt
  GalapagosFinch} og herefter ændre på den eller få yderligere
oplysninger om fx dens alder).

En finke har én {\tt Behavior} (fremover kaldet finkens adfærd).
Det er adfærdens ansvar at afgøre om finken vil hjælpe
en given finke eller ej, ligesom adfærden underrettes om
hvorledes andre finker har handlet overfor finken.

Finkens metoden {\tt decide} bruges når man har brug
for at få at vide, om finken vil hjælpe en anden finke
eller ej (i første tilfælde returneres {\tt
  FinchStatus.CLEANING}, i andet tilfælde returneres {\tt
  FinchStatus.IGNORING}).

Med metoden {\tt response} modtager finken information
om hvordan en given anden finke har handlet mod den. Dette gives
videre til finkens adfærd, ved at kalde dennes
{\tt response}-metode.

Både finkens {\tt decide}- og {\tt response}-metode propagerer
altså ansvaret videre til finkens adfærd.

Metoden {\tt status} bruges til at afgøre om finken er
levende, død af utøj eller død af alderdom, sådan at man kan fjerne
den fra simulationen hvis den ikke længere bør være der.

\subsubsection{\tt Behavior}
% måske bør vi nævne at vi bruger Strategy-pattern
% bare for at vise at vi er bevidste om det.
Interfacet {\tt Behavior} er en specifikation af en finkes adfærd i
forbindelse med møder med andre finker.

Resultatet af {\tt decide} beskriver om en anden finke skal hjælpes
eller ej.

{\tt response} modtager information om hvordan en anden finke handlede
under et møde med den finken som den pågældende adfærd tilhører.

Enhver implementation af {\tt Behavior} har sin egen {\tt
 toString}-metode der returnerer navnet på den givne adfærd
(det er dette navn der i sidste ende bliver vist af vores
bruger-interface). Man kan således bruge {\tt toString} til at afgøre
hvilken konkret klasse et givent {\tt Behavior}-objekt er en
instans af.

Til dette formål har vi dog også krævet at enhver konkret {\tt
  Behavior}-klasse skal overskrive {\tt equals} således at {\tt
  a.equals(b)} er sand for to {\tt Behavior}-objekter hvis og kun
hvis {\tt a} og {\tt b} er instanser af den samme {\tt Behavior}.

{\tt Behavior}-interfacet kræver derfor også at {\tt hashCode}
overskrives så alle {\tt Behavior}s af samme klasse giver samme {\tt
  hashCode} (hvorved specifikationen af {\tt hashCode} i {\tt Object}
er overholdt).

Enhver klasse der repræsenterer en finkeadfærd som afhænger af
hvordan finken er blevet behandlet, udvider den abstrakte klasse {\tt
  MemoryBehavior}.

{\tt MemoryBehavior} er parametriseret med den generiske variabel {\tt
  DATA}, og instansvariablen {\tt finches} er et {\tt
  WeakHashMap<Finch, DATA>}, som bruges når man ønsker at knytte {\tt
  DATA} til en eller anden finke. Dette danner grundlaget for
senere at kunne afgøre hvordan der skal handles i et møde ud fra de
foregående møder.

{\tt MemoryBehavior} indeholder metoden {\tt recall} til at hente den
{\tt DATA} der er knyttet til en given finke, og {\tt remember}
til at knytte {\tt DATA} til en given finke og lagre det i {\tt finches}.

Den abstrakte klasse {\tt ActionMemoryBehavior} udvider {\tt
  MemoryBehavior<Action>}, og udvides af alle typer af adfærd der
til en given finke kun behøver at huske én {\tt Action}.
Eksempler på disse adfærdsmønstre er {\tt Grudger} og {\tt TitForTat}.

\subsubsection{\tt Biotope}

{\tt Biotope}-klassen er simulationens grundsten, den klasse der
implementerer al logikken i programmet. Biotopen har en instans,
{\tt world}, af {\tt World<GalapagosFinch>}.
% {\tt Biotope} er ganske
%simpel at bruge -
En biotop konstrueres bl.a. ud fra en liste
af {\tt Behavior}-objekter, og denne liste indeholder alle de
adfærdsmønstre som finker i biotopen skal kunne have. Derudover kan man ved
konstruktion af en biotop angive størrelsen af {\tt world},
ynglesandsynlighed, maksimalt antal livspoint af en finke, startpoint,
rundepris, nedre grænse for maksimal alder, øvre grænse for maksimal
alder og antallet af finker med hver opførsel der skal sættes i verden
når simulationen startes. De mulige opførsler og de andre parametre
kan ikke ændres når biotopen er skabt.

Ved at kalde metoden {\tt runRound} simuleres en enkelt runde, og
eventuelle observerende objekter gøres opmærksomme på ændringer i
simulationens tilstand. Det er biotopobjektets ansvar at
oprette og vedligeholde verdenen ({\tt world}) og finkerne i den.

For at simulationen skal være fair, er det nødvendigt at finkerne i
tilfældig rækkefølge får mulighed for at få afkom. Der opstår nemlig
utvivlsomt situationer hvor flere finker deles om samme tomme nabofelt
som kan fyldes med afkom, og så er det ikke en god idé at bruge en
naiv iteration, som f.eks. række for række igennem verden, da det så
ville favoritisere finker nordvest i verdenen. Ligeledes må vi på
tilfældig vis løbe finkerne igennem for at finde en mødepartner til dem.
Det er biotopobjektets ansvar at sørge for at disse situationer
bliver løst på fair vis.

Det er også biotopobjektets ansvar at samle ændringer undervejs
i en runde i {\tt Statistics}-objekter. Et sådant objekt indeholder
information om hvor mange finker der er, hvor mange nye finker der er
kommet til verden, og hvor mange der har forladt verden pga. hhv. utøj
og alderdom. Disse statistikker kan bruges af observerende
objekter til at få et bredt billede af begivenhederne i en runde og
over længere tid.

I implementationen af {\tt Biotope} har vi afviget fra den oprindelige
opgaveformulering, idet vi fandt det uretfærdigt at to finker, der
indgår i et møde hvor de begge ignorerer den anden, hver får et
livspoint, mens en finke, der ikke deltager i et møde i en runde, ikke
får et livspoint. Vi ser ikke ideen i at det skulle være mere
fordelagtigt at deltage i et møde, hvor begge deltagere ignorerer den
anden, end slet ikke at deltage i et møde - hverken fra et
biologisk eller spilteoretisk synspunkt er dette rimeligt. Derfor vil
finker, der i en runde ikke deltager i et møde, i vores
implementation få tildelt et enkelt livspoint.

\subsubsection{Biotope.FinchDescriptor}

I vores program tilbyder vi muligheden for at indsætte og fjerne
finker under kørsel - denne manipulation er ikke nødvendigvis
begrænset til enkelte felter, men kan i stedet påvirke adskillige
felter inden i en cirkel på samme tid. Den åbenlyse implementation har
en klar defekt - efter hver manipulation, det være at fjerne eller
tilføje en finke til et felt, bliver metoden {\tt notifyObservers}
kaldet og den grafiske repræsentation opdateret. Dette betyder at man
i stedet for blot at se en cirkel blive udfyldt med finker af den
valgte opførsel på en gang, vil kunne iagttage cirklen blive udfyldt
felt for felt, en både ydelsesmæssigt og brugerinterfacemæssig defekt.
Vi ønsker altså at lave en serie af ændringer uden at {\tt
  notifyObservers} bliver kaldt imellem, men samtidigt ønsker vi ikke
at give klienter til {\tt Biotope} mulighed for at ændre tilstanden
uden at observatører bliver oplyst om det. At understøtte dette i {\tt
  Biotope} kræver et særligt design baseret på designmønstret {\em
  Visitor}. Overordnet defineres der en offentlig abstrakt indre
klasse i {\tt Biotope} ved navn {\tt FinchDescriptor} - instanser af
underklasser af denne klasse beskriver en handling på et specifikt
felt i biotopen, og i {\tt Biotope} er en metode {\tt
  applyDescriptors} defineret, som sørger for at de handlinger, der er
beskrevet af en liste af {\tt FinchDescriptor}-objekter, bliver
udført, og eventuelle observatører orienteret om eventuelle ændringer.
{\tt FinchDescriptor}-klassen specificerer en metode {\tt apply} som
bruges til at udføre ændringen beskrevet i det konkrete {\tt
  FinchDescriptor}-objekt på den leverede {\tt Biotope}-instans. Dette
sikrer os fra at være nødsaget til at bruge {\tt instanceof} til
specifikt at håndtere alle underklasser af {\tt FinchDescriptor} i
{\tt applyDescriptors}, men i stedet uddelegere dette til det konkrete
objekt, som så er i stand til at benytte private metoder i {\tt
  Biotope} til at udføre sin beskrevne ændring uden at {\tt
  notifyObservers} bliver kaldt. Brugen af {\em Vistor}-mønstret
betyder ikke udpræget meget i vores konkrete implementation, men hvis
det i fremtiden skulle være nødvendigt at tilføje flere underklasser
af {\tt FinchDescriptor} ville det kunne gøres uden at modificere
resten af Biotope.

\subsection{Brugerinterface}
Vores brugerinterface bruges til at styre og vise biotopobjekter.
Det består som udgangspunkt af en instans af {\tt GalapagosFrame}. Dette
vindue giver brugeren mulighed for gennem knapper at kontrollere den
nuværende biotop. Dette sker gennem en instans af {\tt
  BiotopeController} der modtager "events" fra knapperne på vinduet,
og ud fra dette får biotopen til at udføre det tilsvarende antal
runder af simulationen. {\tt GalapagosFrame} giver desuden brugeren
mulighed for at iagttage biotopen såvel visuelt (gennem en instans af
{\tt AreaPanel}) som gennem en tabel over den nuværende tilstand af
de forskellige adfærdsmønstre i biotopen. Der er endda mulighed for
at aktivere en ekstra funktionalitet der udskriver tabellens data til
{\tt System.out} ved hjælp af klassen {\tt BiotopeLogger}. Sidste
overordnede komponent i bruger-interfacet er det selvstændige vindue
{\tt BiotopeCreator} som man kan få adgang til fra {\tt
  GalapagosFrame}. {\tt BiotopeCreator} giver mulighed for at
specificere parametrene for en ny {\tt Biotope} der derefter kan
iagttages og manipuleres gennem {\tt GalapagosFrame}.

\subsubsection{\tt GalapagosFrame}
En {\tt GalapagosFrame} er den komponent der står for at oprette alle
de andre hovedkomponenter i programmet (dvs. selve biotopobjektet,
en {\tt BiotopeController} og de andre dele af
bruger-interfacet). {\tt GalapagosFrame} tager en {\tt Map<Behavior,
  Color>} som argument i sin konstruktør. Denne {\tt Map} specificerer
hvilke adfærdsmønstre der mulige at have med i
biotoper i programmet, samt hvilke farver der repræsenterer de
forskellige adfærdsmønstre i den visuelle visning af biotoperne. Det
er på denne måde let at introducere nye adfærdsmønstre til programmet
da dette kun skal gøres et enkelt sted hvorefter resten af programmet
skalerer sig selv til at passe med antallet af adfærdsmønstre.

Den visuelle repræsentation af {\tt GalapagosFrame} er delt op i fem
områder (paneler).

Det øverste panel indeholder de primære kontrolmuligheder for
den aktuelle biotop. Alle komponenterne på dette panel (bortset
fra knappen ``New Biotope'') sender events til {\tt
  BiotopeController}'en der håndterer de konkrete deltaljer om at få
biotopen til at udføre det ønskede antal simulationsrunder (``Next
Round'': én runde; ``Several Rounds'': det angivne antal runder;
``Go!'': et ubegrænset antal runder) eller stoppe udførslen af
flere runder (``Stop Simulation''). ``New Biotope''-knappen åbner
programmets {\tt BiotopeCreator} der står for at indsamle gyldige
parametre fra brugeren til en ny biotop, og undervejs er det
ikke muligt at manipulere med den nuværende biotop - idet {\tt
  BiotopeCreator}'en bliver vist som en modal dialog.

Det midterste panel på {\tt GalapagosFrame} indeholder den visuelle
visning af biotopen i form af en instans af {\tt AreaPanel}. {\tt
  AreaPanel} er tilføjet som {\tt Observer} til den nuværende {\tt
  Biotope}, og opdaterer sig selv når den aktuelle biotop
ændrer sig. {\tt AreaPanel} ændrer desuden pixel-størrelsen for de
enkelte felter i visningen af biotopen således at hele biotopen vises
så stort som muligt på vinduet (forudsat at vinduet ikke gøres så småt
at biotopen ikke kan vises selv med en feltstørrelse på 1x1 pixels).

Panelet til højre på vinduet indholder en {\tt OptionButton} for hver
adfærd i biotopen (dvs. kun dem der var i biotopen da denne
blev oprettet), og gør det i kombination med {\tt AreaPanel} muligt at
tilføje nye finker til biotopen med musen (venstre musetast).
Tilsvarende kan man slette finker med højre musetast (om det virkelig
er den højre musetast er muligvis muse- og systemafhængigt).
En {\tt JSlider} under
disse knapper gør det muligt at variere radius på ``finkepenslen''.

Det venstre panel indeholder tre indstillingsmuligheder. Det er muligt
at indstille det minimale tidsrum der går mellem at en
simulationsrunde udføres i biotopen (når {\tt BiotopeController}'en er
sat til at udføre flere runder i træk). Det er desuden muligt at slå
opdateringen af {\tt AreaPanel} fra, hvilket kan mindske tiden for
udførsel af mange runder i træk. Til sidst indeholder det venstre
panel muligheden for at aktivere en {\tt BiotopeLogger} der udskrive en
statistik over de enkelte adfærdsmønstre til {\tt System.out} hver
runde. {\tt BiotopeLogger} bliver tilføjet som {\tt Observer} til den
aktuelle biotop, men er desuden beskrevet yderligere nedenfor.

Det nederste panel indeholder et {\tt StatisticsPanel} der hver
runde opdateres med en generel status for hver af de adfærdsmønstre
der er i biotopen. Dette foregår også ved at {\tt
  StatisticsPanel} bliver tilføjet som {\tt Observer} til den
nuværende biotop. Da {\tt StatisticsPanel} får den
anvendte {\tt Map<Behavior, Color>} med i sin konstruktør, er det
derefter uafhængigt af {\tt GalapagosFrame}, og kan med meget få
kodemæssige ændringer erstattes af et andet (og måske) bedre panel til
udskrivning af information om biotop-tilstanden til brugeren.  {\tt
  StatisticsPanel} er beskrevet yderligere nedenfor.

\subsubsection{\tt BiotopeController}

{\tt BiotopeController}'en står for at styre biotopen ud fra hvad
brugeren klikker på i det grafisk brugerinterface. Dens primære
funktion er at få biotopen til at køre nogle runder.  Når brugeren
eksempelvis beder om at lade simulationen køre i 30 runder, så vil
kontrollen sørge for at de 30 runder bliver kørt. På samme måde sørger
den for at stoppe simulationen når brugeren beder om det.

Kontrollen bruger en {\tt Timer} til at køre runderne, den gør det
enkelt at ændre hvor lang tid der skal gå i mellem runde eller om
programmet bare skal køre så hurtigt som maskinen tillader.

Vi har gjort det muligt selv at indsætte og fjerne finker fra biotopen
vha. musen, det er også kontrollen der ændrer biotopen når dette er
sket.

\subsubsection{\tt BiotopeLogger}
{\tt BiotopeLogger} er som beskrevet ovenfor en {\tt Observer}
 der sørger for at
udskrive statistik om hver enkelt runde. For at få statistikken gjort
enklere at læse har vi formateret den på tabelform. En naiv metode til
at hente statistikken for hver adfærd ville være at man for hver kolonne
man vil have (f.eks. antallet af fødte finker) kaldte den
tilsvarende metode på statistikobjektet. Statistikklassen
({\tt Statistics}) gør
dette meget nemmere end som så, da den har et {\tt enum
  StatisticsElement} der indeholder alle de forskellige elementer der
er i et statistikobjekt. For at lave en kolonne for hver type
statistik gennemløber vi bare alle de forskellige statistikelementer
og beder statistikobjekterne om de værdier der svarer til de
enkelte statistikelementer. Ved at kalde {\tt name()} på et
statistikelement kan man få en forklaring i tekst af hvad dette
statistikelement angiver, dette bruger vi til titlerne i kolonnerne.
På den måde er det også blevet nemmere at udbygge statistikklassen så
den kan gemme statistik over flere ting, uden at man også skal ændre
på loggeren. For at loggeren også virker når et statistikobjekt
indeholder store tal
har vi gjort så kolonnerne udvider sig i bredden alt efter hvor
meget tekst der skal stå i de enkelte celler.

Den nederste række i tabellen er en total for hver af de enkelte
kolonner - den bliver udregnet undervejs og tilsidst tilføjet som
sidste række i det todimensionale array. 

For at gøre det nemmere at se hvornår en race uddør har vi lavet et
specialtilfælde for hvordan antallet af finker med en given adfærd
udskrives.
Når der 0 finker af
en slags skriver vi at den slags er uddød. Tilsvarende gøres i
total-rækken opmærksom på når der ikke er nogen levende finker
tilbage.

\subsubsection{\tt StatisticsPanel}
{\tt StatisticsPanel}
fungere på stort set samme måde som {\tt BiotopeLogger}, men da det
her skal vises i et Java-vindue bliver vi nødt til at bruge nogle
Java-komponenter til at vise teksten. Den fundamentale forskel på {\tt
  BiotopeLogger} og {\tt StatisticsPanel} er at panelet har et
todimensionalt array af {\tt JLabel}s, som den ændrer teksten på hver gang
der er sket en opdatering, mens {\tt BiotopeLogger}en hver runde
konstruerer et
todimensionalt array af tekstværdier som den så udskriver.

\section{Konklusion}
Vores program virker (så vidt vi kan se) efter hensigten. Vi mener at
vores program i\-mø\-de\-kom\-mer alle opgavens krav.

Vi har valgt ikke at
implementere bevægelse af finkerne. Det forringer
finkernes mulighed for at benytte sig af deres eventuelle
hukommelse, idet det meget sjældnere vil ske at to finker gentagne
gange mødes, og det synes vi er en stor ulempe.

Vi har også valgt ikke at implementere mutation blandt finkerne. Vi er
interesserede i at studere hvordan bestemte adfærdsmønstre klarer sig
i forhold til hinanden, og mutation ville
besværliggøre dette.

Vi har heller ikke implementeret en adfærdstype hvor afkom arver
ophavets viden om andre finker. Det vil være temmelig nemt at lave ved i
en adfærds {\tt clone}-metode at sørger for at den nye instans af
adfærden får en kopi af den gamle instans' erindringer.

Af udvidelser af programmet som vi gerne ville lave kan nævnes:
\begin{itemize}
\item[1.]
  Grafer som viser antallene af finker tilhørende de forskellige
  adfærdsmønstre gennem hele den pågældende simulation. Dette ville
  især være interessant i biotoper hvor antallet af finker
  tilsyneladende ændrer sig periodisk (fx Cheaters mod Samaritans i en
  $30\times 30$-biotop).
\item[2.]
  En facilitet der gør det muligt at få programmet til at afholde
  ``turneringer'' i overlevelse. Man vælger en mængde
  forskellige adfærdsmønstre og specificerer turneringsbiotopens
  egenskaber, hvorefter programmet konstruerer og simulerer
  én-mod-én-biotoper for at finde en mulig rangorden af de
  specificerede adfærdsmønstres overlevelsesevner.
\end{itemize}
\end{document}
Troels Henriksen