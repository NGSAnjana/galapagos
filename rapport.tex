\documentclass{article}
\usepackage[latin1]{inputenc}
\usepackage[danish]{babel}

\textheight = 625pt \textwidth = 400pt \oddsidemargin = 25pt

\pagestyle{plain}

\title{Eksamensprojekt i Objektorienteret \linebreak programmering og design}

\author{Martin Dybdal, Mikkel Abrahamsen, Sune Precht Reeh, Troels Henriksen}

\date{Januar 2007}
\begin{document}
\maketitle

\section{Forfatterinformation}


Mikkel Abrahamsen

\noindent Jagtvej 120,3,-346

\noindent 2200 København N

\noindent Eksamensnummer: 37

\vspace{20pt} \noindent Sune Precht Reeh

\noindent Kai Hoffmanns Allé 27

\noindent 2750 Ballerup

\noindent Eksamensnummer: 64

\vspace{20pt} \noindent Troels Henriksen

\noindent Åparken 48

\noindent 2605 Brøndby

\noindent Eksamensnummer: 72

\section{Indledning}

\section{Programdesign}

\subsection{Model}

\subsubsection{\tt World}

Den fundamentale datastruktur, der ligger til grund for hele
simulationens  verden, er den passende navngivede klasse {\tt World}.
Denne klasse giver i sin enkelthed adgang til et todimensionalt array
af {\tt World.Place} objekter. Disse {\tt World.Place}s skaber
verdens torusform, som krævet i opgaven, idet de har metoder til at
finde nabo-{\tt World.Place}s. Et af disse objekter, placeret på en
kant, vil give de passende objekter på den modsatte kant, når der
bliver spurgt om dets naboer. Et {\tt World.Place}-objekt kan
indeholde et andet objekt - dets {\em element}. I vores simulation er
finke-objekterne placeret som elementer i {\tt World.Place}-objekter,
men da man kan forestille sig at der sidenhen kan være behov for at
lave {\tt World}-strukturer med andre typer objekter end finker, har
vi valgt at parametrisere {\tt World}-klassen over den type elementer
som {\tt World.Place}-objekterne indeholder.

Metoderne {\tt World.Place.filledNeighbors} og {\tt
  World.Place.emptyNeighbors} bruges til at finde alle de naboceller der
  hhv. indeholder elementer eller er tomme. De skal benyttes når
  finker skal få afkom og møde andre finker.

Under simulationen er der endnu en interessant facilitet vi
ofte har behov for at udføre på vores verden. Når der skal arrangeres
møder og skabes afkom skal vi iterere igennem alle finker i verden,
men for ikke skabe favoritter, skal dette helst ske i pseudotilfældig
rækkefølge. Ydermere ønsker vi et iteratorbaseret interface for at
gøre koden så elegant som muligt. En åbenlys implementation er at lade
{\tt World} klone dets underliggende lager (en enkeltdimensional {\tt
  ArrayList}), kalde {\tt Collections.shuffle} på det nye array, og
returnere en iterator. Dette ville resultere i allokeringen af et nyt
array for hver gang vi har behov for at iterere igennem elementerne i
{\tt World} i pseudotilfældig rækkefølge - en åbenlys ineffektiv
implementation. Vi har - ved at observere at {\tt
  World.Place}-objekterne i {\tt World} altid er de samme (det er
kun deres
elementer der ændrer sig) -
fundet på en mere effektiv implementation, hvor vi i {\tt
  World}, sideløbende med det almindelige lager, gemmer et alternativt
lager, der indeholder de samme {\tt World.Place}-objekter som det
primære, men i en anden rækkefølge. Idet det er de samme {\tt
  World.Place}-objekter der bliver modificeret når der tilføjes og
fjernes finker, vil dette sekundære array altid være opdateret mht.
indhold, og vi kan implementere tilfældig iteration blot ved at kalde
{\tt
  Collections.shuffle} på det og returnere en iterator. Derved slipper
vi for at skulle klone vores underliggende array hver gang vi har
behov for pseudotilfældig iteration.

\subsubsection{\tt GalapagosFinch}

En instans af klassen {\tt GalapagosFinch} repræsenterer én
finke. Klassen {\tt GalapagosFinch} implementerer interfacet {\tt
  Finch}, der bruges som reference til en {\tt GalapagosFinch} på
steder hvor det ikke er tilsigtet at man skal kunne få ekstra
oplysninger om {\tt GalapagsoFinch}en eller ændre den på nogen måde
(det vil naturligvis stadig være muligt at "type-caste" en {\tt
Finch} til {\tt GalapagosFinch} og herefter ændre på den eller få
yderligere oplysninger om fx dens alder).

En {\tt GalapagosFinch} har én {\tt Behavior}. Det er {\tt
  Behavior}ens ansvar at afgøre om {\tt GalapagosFinch}en vil hjælpe
en given finke eller ej, ligesom {\tt Behavior}en underrettes om
hvorledes andre finker har handlet overfor {\tt GalapagosFinch}en.

Metoden {\tt decide} i {\tt GalapagosFinch} bruges når man har brug
for at få at vide, om {\tt GalapagosFinch}en vil hjælpe en anden {\tt
Finch} eller ej (i første tilfælde returneres {\tt
FinchStatus.CLEANING}, i andet tilfælde returneres {\tt
FinchStatus.IGNORING}). Når {\tt decide} kaldes returneres resultatet
af {\tt Behavior}ens {\tt decide}-metode på den pågældende finke.

Med metoden {\tt response} modtager {\tt GalapagosFinch}en information
om hvordan en given anden {\tt Finch} har handlet mod den. Dette gives
videre til {\tt GalapagosFinch}ens {\tt Behavior}, ved at kalde dennes
{\tt response}-metode.

Metoden {\tt status} bruges til at afgøre om {\tt GalapagosFinch}en
 er levende, død af utøj
eller død af alderdom, sådan at man kan fjerne den fra simulationen
hvis den ikke længere bør være der.

\subsubsection{\tt Behavior}

Interfacet {\tt Behavior} er en specifikation af en finkes opførsel
i forbindelse med møder med andre finker.

Resultatet af {\tt decide} beskriver om en {\tt Finch} skal hjælpes
eller ej.

{\tt response} modtager information om hvordan en anden finke
handlede under et møde med den {\tt GalapagosFinch} som den
pågældende {\tt Behavior} tilhører.

Enhver implementation af {\tt Behavior} har sin egen {\tt
toString}-metode der returnerer navnet på den givne {\tt Behavior}
(det er dette navn der i sidste ende bliver vist af vores
bruger-interface). Man kan således bruge {\tt toString} til at afgøre
hvilken konkret klasse som et givent {\tt Behavior}-objekt er en
instans af.

Til dette formål har vi dog også krævet at enhver konkret {\tt
Behavior}-klasse skal overskrive {\tt equals} således at {\tt
a.equals(b)} for to {\tt Behavior}s objekter hvis og kun hvis {\tt a}
og {\tt b} er instanser af den samme {\tt Behavior}.

{\tt Behavior}-interfacet kræver derfor også at {\tt hashCode}
overskrives så alle {\tt Behavior}s af samme klasse giver samme {\tt
hashCode} (hvorved specifikationen af {\tt hashCode} i {\tt Object}
er overholdt).

Enhver klasse der
repræsenterer en finkeopførsel som afhænger af hvordan finken er
blevet behandlet, udvider den abstrakte klasse {\tt
  MemoryBehavior}.

{\tt MemoryBehavior} er parametriseret med den generiske variabel {\tt
  DATA}, og instansvariablen {\tt finches} er et
{\tt WeakHashMap<Finch, DATA>}, som bruges når man ønsker at knytte
{\tt DATA} til en eller anden {\tt Finch}. Dette danner grundlaget for
senere at kunne afgøre hvordan der
skal handles i et møde ud fra de foregående møder.

{\tt MemoryBehavior} indeholder metoden {\tt recall} til at hente den {\tt
  DATA} der er knyttet til en given {\tt Finch}, og {\tt remember}
til at knytte {\tt DATA}
til en given {\tt Finch} i {\tt finches}.

Den abstrakte klasse {\tt ActionMemoryBehavior} udvider {\tt
  MemoryBehavior<Action>}, og udvides af alle typer af opførsler
der til en given {\tt Finch} kun behøver at huske én {\tt Action}.
Eksempler på dette er {\tt Grudger} og {\tt TitForTat}.

\subsubsection{\tt Biotope}

{\tt Biotope}-klassen er simulationens grundsten, den klasse der
implementerer al logikken i programmet. {\tt Biotope} har en instans,
{\tt world}, af {\tt World<GalapagosFinch>}. {\tt Biotope} er ganske simpel
at bruge - en {\tt Biotope} konstrueres bl.a. ud fra en liste af {\tt
  Behavior}-objekter, og denne liste indeholder alle de opførsler som
finker i biotopen skal kunne have. Derudover kan man ved konstruktion
af en {\tt Biotope} angive størrelsen af {\tt world},
ynglesandsynlighed, maksimalt antal livspoint af en finke,
startpoint, rundepris, nedre grænse for maksimal alder, øvre grænse
for maksimal alder og antallet af finker med hver opførsel der skal
sættes i verden når simulationen startes. De mulige opførsler og de
andre parametre kan ikke ændres når biotopen er skabt.

Ved at kalde metoden {\tt
  runRound} simuleres en enkelt runde, og eventuelle
observerende objekter gøres opmærksomme på ændringer i simulationens
tilstand. Det er {\tt Biotope}-klassens ansvar at oprette og
vedligeholde verdenen ({\tt world})
og finkerne ({\tt GalapagosFinch}'erne) i den.

For at simulationen skal være fair, er det nødvendigt at finkerne i
tilfældig rækkefølge får mulighed for at få afkom. Der
opstår nemlig utvivlsomt situationer hvor flere finker deles om samme tomme
nabofelt som kan fyldes med afkom, og så er det ikke en god idé at
bruge en naiv
iteration, som f.eks. række for række igennem verden, da det så ville
favoritisere finker nordvest i spilverdenen. Ligeledes må vi på
tilfældig vis løbe finkerne igennem og finde en mødepartner til dem.
Det er {\tt
  Biotope}-klassens ansvar at sørge for at disse situationer bliver
løst på fair vis.

Det er også {\tt Biotope}-klassens ansvar at samle ændringer
undervejs i en runde i {\tt Statistics}-objekter. Et sådant objekt
indeholder information om hvor mange finker der er, hvor mange nye
finker der er kommet til verden, og hvor mange der har forladt verden
pga. hhv. utøj og alderdom. Disse {\tt Statistics} kan bruges af
observerende objekter til at få et bredt billede af begivenhederne i
en runde og over længere tid.


\subsection{Brugerinterface}

\section{Konklusion}

\end{document}
