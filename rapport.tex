\documentclass{article}
\usepackage[latin1]{inputenc}

\pagestyle{plain}

\title{Eksamensproject i Object-Orienteret Programmering \& Design}

\author{Martin Dybdal, Mikkel Abrahamsen, Sune Precht Reeh, Troels Henriksen}

\date{Januar 2007}
\begin{document}
\maketitle

\section{Forfatterinformation}

Mikkel Abrahamsen \\
\noindent
Jagtvej 120,3,-346 \\
\noindent
2200 København N \\
\noindent
Eksamensnummer: 37

\section{Indledning}

\section{Programdesign}

\subsection{Model}

\subsubsection{\tt World}

Den fundamentale datastruktur, der ligger til grund for hele
simulationens  verden, er den passende navngivne klasse {\tt World}.
Denne klasse giver i sin enkelthed adgang til et todimensionelt array
af {\tt World.Place} objekter. Disse {\tt World.Place}s skaber
verdens torusform, som krævet i opgaven, idet de har metoder til at
finde nabo-{\tt World.Place}s. Et af disse objekter, placeret på en
kant, vil give de passende objekter på den modsatte kant, når der
bliver spurgt om sine naboer. Et {\tt World.Place} objekt kan også
indeholde et andet objekt - dets {\em element}. I vores simulation er
finke-objekterne placeret som elementer i {\tt World.Place} objekter,
men da man kan forestille sig at der sidenhen kan være behov for at
lave {\tt World}-strukturer med andre typer objekter end finker, har
vi valgt at benytte generics til {\tt World}-klassen.

Metoderne {\tt World.Place.filledNeighbors} og {\tt
  World.Place.emptyNeighbors} bruges til at finde de naboceller der
  hhv. indeholder elementer eller er tommer. De skal benyttes når
  finker skal få afkom og møde andre finker.

Under simulationen er der ydermere endnu en interessant facilitet, vi
ofte har behov for at udføre på vores verden - når der skal arrangeres
møder og skabes afkom, skal vi iterere igennem alle finker i verden,
men for ikke skabe favoritter, skal dette helst ske i pseudotilfældig
rækkefølge. Ydermere ønsker vi et iteratorbaseret interface for at
gøre koden så elegant som muligt. En åbenlys implementation er at lade
{\tt World} klone dets underliggende lager (en enkeltdimensional {\tt
  ArrayList}), kalde {\tt Collections.shuffle} på det nye array, og
returnere en iterator. Dette ville resultere i allokeringen af et nyt
array for hver gang vi har behov for at iterere igennem elementerne i
{\tt World} i pseudotilfældig rækkefølge - en åbenlys ineffektiv
implementation. Vi har dog - ved at observere at {\tt
  World.Place}-objekterne i {\tt World} aldrig ændrer sig, kun deres
elementer - fundet på en mere effektiv implementation, hvor vi i {\tt
  World}, sideløbende med det almindelige lager, gemmer et alternativt
lager, der indeholder de samme {\tt World.Place} objekter som det
primære, men i en anden rækkefølge. Idet det er de samme {\tt
  World.Place}-objekter der bliver modificeret når der tilføjes og
fjernes finker, vil dette array altid være opdateret mht. indhold, og
vi kan implementere tilfældig iteration blot ved at kalde {\tt
  Collections.shuffle} på det og returnere en iterator. Derved slipper
vi for at skulle klone vores underliggende array hver gang vi har
behov for pseudotilfældig iteration.

\subsection{Brugerinterface}

\section{Konklusion}

\end{document}
